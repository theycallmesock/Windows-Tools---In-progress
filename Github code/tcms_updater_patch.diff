*** Begin Patch
*** Add File: Updater/Program.cs
+using System;
+using System.Diagnostics;
+using System.IO;
+using System.Threading;
+
+//
+// Small updater helper. Build as a separate minimal console app (single-file not required).
+// Usage: Updater.exe "<downloadedNewExePath>" "<targetExePath>"
+//
+class Program
+{
+    static int Main(string[] args)
+    {
+        try
+        {
+            if (args.Length < 2)
+            {
+                Console.WriteLine("Usage: Updater <newExe> <targetExe>");
+                return 2;
+            }
+
+            var newExe = args[0];
+            var targetExe = args[1];
+
+            Console.WriteLine($"Updater starting. newExe={newExe} targetExe={targetExe}");
+
+            // Ensure newExe exists
+            if (!File.Exists(newExe))
+            {
+                Console.WriteLine("New exe missing.");
+                return 3;
+            }
+
+            // Find any running processes that lock the target exe
+            var targetName = Path.GetFileNameWithoutExtension(targetExe);
+            foreach (var p in Process.GetProcessesByName(targetName))
+            {
+                try
+                {
+                    if (p.MainModule?.FileName != null &&
+                        string.Equals(Path.GetFullPath(p.MainModule.FileName), Path.GetFullPath(targetExe), StringComparison.OrdinalIgnoreCase))
+                    {
+                        Console.WriteLine($"Found running process {p.Id} - waiting for exit...");
+                        p.WaitForExit(30_000); // wait up to 30s
+                        if (!p.HasExited)
+                        {
+                            Console.WriteLine("Process still running; attempting to close...");
+                            try { p.CloseMainWindow(); } catch { }
+                            Thread.Sleep(3000);
+                            if (!p.HasExited) { p.Kill(); p.WaitForExit(5000); }
+                        }
+                    }
+                }
+                catch
+                {
+                    // Access denied to main module -> still wait briefly
+                    Thread.Sleep(2000);
+                }
+            }
+
+            // Try to replace file. If locked, retry and fallback to move-on-reboot.
+            var backup = targetExe + ".bak_" + DateTime.UtcNow.ToString("yyyyMMddHHmmss");
+            try
+            {
+                if (File.Exists(targetExe))
+                {
+                    // Move old exe to backup
+                    File.Move(targetExe, backup);
+                    Console.WriteLine($"Moved old exe to {backup}");
+                }
+                // Move new exe into place
+                File.Move(newExe, targetExe);
+                Console.WriteLine("Replaced exe successfully.");
+            }
+            catch (Exception ex)
+            {
+                Console.WriteLine($"Replace failed: {ex}. Scheduling replace on reboot.");
+                // Schedule move-on-reboot
+                bool ok = MoveFileEx(newExe, targetExe, MoveFileFlags.MOVEFILE_REPLACE_EXISTING | MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
+                Console.WriteLine($"MoveFileEx scheduled: {ok}");
+            }
+
+            // Relaunch new exe
+            try
+            {
+                Process.Start(new ProcessStartInfo { FileName = targetExe, UseShellExecute = true });
+                Console.WriteLine("Relaunched target exe.");
+            }
+            catch (Exception ex)
+            {
+                Console.WriteLine($"Relaunch failed: {ex}");
+            }
+
+            return 0;
+        }
+        catch (Exception ex)
+        {
+            Console.WriteLine($"Updater exception: {ex}");
+            return 1;
+        }
+    }
+
+    // P/Invoke MoveFileEx for scheduling replacement on reboot
+    [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
+    private static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);
+
+    [Flags]
+    private enum MoveFileFlags : uint
+    {
+        MOVEFILE_REPLACE_EXISTING = 0x1,
+        MOVEFILE_COPY_ALLOWED = 0x2,
+        MOVEFILE_DELAY_UNTIL_REBOOT = 0x4,
+        MOVEFILE_WRITE_THROUGH = 0x8
+    }
+}
+
*** End Patch
*** Begin Patch
*** Add File: Updater/Updater.csproj
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFramework>net8.0</TargetFramework>
+    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
+    <PublishSingleFile>false</PublishSingleFile>
+    <SelfContained>false</SelfContained>
+    <ImplicitUsings>enable</ImplicitUsings>
+  </PropertyGroup>
+</Project>
+
*** End Patch
*** Begin Patch
*** Add File: Tools/release_and_embed.ps1
+<#
+Safe release automation script (PowerShell).
+#>
+param(
+    [Parameter(Mandatory=$true)][string]$Version,
+    [Parameter(Mandatory=$true)][string]$Tag,
+    [Parameter(Mandatory=$true)][string]$Repo,
+    [string]$Notes = "Release created by release_and_embed.ps1",
+    [string]$MainProject = "TCMS.Optimizer.csproj",
+    [string]$UpdaterProject = "Updater/Updater.csproj",
+    [string]$OutDir = "publish",
+    [switch]$PushAppManifest
+)
+Set-StrictMode -Version Latest
+dotnet publish $UpdaterProject -c Release -r win-x64 --self-contained false -o out/updater
+if ($LASTEXITCODE -ne 0) { throw "Failed to publish Updater" }
+if (-not (Test-Path "Tools/embedded")) { New-Item -ItemType Directory -Path "Tools/embedded" | Out-Null }
+Copy-Item -Path "out/updater/Updater.exe" -Destination "Tools/embedded/Updater.exe" -Force
+dotnet publish $MainProject -c Release -r win-x64 --self-contained true /p:PublishSingleFile=true /p:PublishTrimmed=false -o $OutDir
+if ($LASTEXITCODE -ne 0) { throw "Failed to publish main exe" }
+$exePath = Join-Path -Path $OutDir -ChildPath "TCMS_Optimizer.exe"
+if (-not (Test-Path $exePath)) { throw "Published exe not found at $exePath" }
+$hash = (Get-FileHash -Algorithm SHA256 $exePath).Hash.ToLower()
+gh release create $Tag $exePath --repo $Repo --title $Tag --notes $Notes
+$releaseUrl = "https://github.com/$Repo/releases/download/$Tag/TCMS_Optimizer.exe"
+$appupdate = @{ version = $Version; url = $releaseUrl; sha256 = $hash; notes = $Notes }
+$appupdate | ConvertTo-Json -Depth 4 | Out-File -FilePath appupdate.json -Encoding utf8
+if ($PushAppManifest.IsPresent) {
+  git add appupdate.json
+  git commit -m "Add appupdate manifest $Version"
+  git push origin HEAD
+}
+
*** End Patch
*** Begin Patch
*** Update File: TCMS.Optimizer.csproj
@@
   <ItemGroup>
     <!-- Embed default scripts as resources -->
     <None Update="Resources\scripts\fps_boost.ps1">
       <CopyToOutputDirectory>Never</CopyToOutputDirectory>
       <Pack>True</Pack>
       <Visible>false</Visible>
     </None>
     <None Update="Resources\scripts\latency_boost.ps1">
       <CopyToOutputDirectory>Never</CopyToOutputDirectory>
       <Pack>True</Pack>
       <Visible>false</Visible>
     </None>
     <None Update="Resources\scripts\restore_defaults.ps1">
       <CopyToOutputDirectory>Never</CopyToOutputDirectory>
       <Pack>True</Pack>
       <Visible>false</Visible>
     </None>
   </ItemGroup>
 
+  <ItemGroup>
+    <!-- The Updater helper will be embedded as an embedded resource.
+         Build the Updater project and copy Updater.exe to Tools\embedded\Updater.exe before building/publishing main project.
+         LogicalName is set so UpdateManager.ExtractEmbeddedUpdater() will find it by name. -->
+    <EmbeddedResource Include="Tools\embedded\Updater.exe">
+      <LogicalName>TCMS.Updater.exe</LogicalName>
+    </EmbeddedResource>
+  </ItemGroup>
+
*** End Patch